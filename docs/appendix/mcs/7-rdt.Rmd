---
output: 
  md_document:
    variant: markdown_mmd
---

# 7 递归的数据类型

**递归数据类型** 在编程中起着核心作用, 归纳法也是如此.

递归数据类型由 *递归定义* 指定, 递归定义说明了如何从已有的数据元素构造新的数据元素. 对于每种递归数据类型, 都有该数据类型的属性或函数的递归定义. 更重要的是, 基于递归定义, 有一种 *结构归纳法* 来证明给定类型的所有数据都具有某种属性.

本章考察了一些递归数据类型的例子以及对它们进行递归定义的函数:

-   字符串,
-   “平衡”的括号字符串,
-   非负整数,
-   算术表达式,
-   完全信息的双人游戏.

## 7.1 递归定义和结构归纳法

我们将从使用字符字符串的例子来说明递归定义和证明开始. 通常, 我们会认为字符串是理所当然的, 但将它们视为递归数据类型是有益的. 特别是, 字符串是一个不错的第一个例子, 因为你将看到递归定义的东西很容易理解, 或者你已经知道了, 所以你可以专注于这些定义是如何工作的, 而不必弄清楚它们的含义.

递归数据类型的定义有两个部分:

-   *基本情况* 指定一些已知的数学元素在数据类型中, 和
-   *构造情况* 指定如何从已构造的元素或基本元素构造新的数据元素.

给定字符集 $A$ 上的字符串的定义遵循以下模式:

::: thm
#### 定义 7.1.1.

设 $A$ 为一个非空集合, 称为字母表, 其元素称为字符（也称为字母、符号或数字）. 字母表 $A$ 上的字符串的递归数据类型 $A^*$ 定义如下:

-   基本情况: 空字符串 $\lambda$ 在 $A^*$ 中.

-   构造情况: 如果 $a \in A$ 且 $s \in A^*$, 则对偶 $\langle a, s \rangle \in A^*$.
:::

所以 $\{0, 1\}^*$ 是二进制字符串.

通常将二进制字符串视为0和1的序列. 例如, 我们将长度为4的二进制字符串1011视为位的序列, 4元组(1, 0, 1, 1). 但根据递归定义 7.1.1, 该字符串将表示为嵌套对, 即

$$
\langle 1, \langle 0, \langle 1, \langle 1, \lambda \rangle \rangle \rangle \rangle. 
$$

这些嵌套对确实很繁琐, 也可能看起来很奇怪, 但它们实际上反映了诸如Scheme或Python等编程语言中字符列表的表示方式, 其中 $\langle a, s \rangle$ 对应于cons(a, s).

请注意, 我们并没有确切地说出空字符串是如何表示的. 这实际上并不重要, 只要我们能识别空字符串并且不与任何非空字符串混淆.

继续递归方法, 让我们定义字符串的长度.

::: thm
#### 定义 7.1.2.

字符串 $s$ 的长度 $|s|$ 基于定义 7.1.1 递归地定义如下:

-   基本情况: $|\lambda| ::= 0$.

-   构造情况: $|\langle a, s \rangle| ::= 1 + |s|$.
:::

这个长度的定义遵循一个标准模式: 递归数据类型上的函数可以使用与数据类型定义相同的情况递归定义. 具体来说, 要定义递归数据类型上的函数 $f$, 首先定义 $f$ 在数据类型定义的基本情况中的值, 然后定义 $f$ 在每个构造情况中的值作为 $f$ 在组件数据项上的值的函数.

让我们做另一个例子: 字符串 $s$ 和 $t$ 的连接 $s \cdot t$ 是由 $s$ 的字母后跟 $t$ 的字母组成的字符串. 这是一个完全清晰的连接的数学定义（除了如何处理空字符串的问题）, 并且在Scheme/Python列表的术语中, $s \cdot t$ 将是append(s, t). 这是一个连接的递归定义.

::: thm
**定义 7.1.3.** 字符串 $s$ 和 $t$ 的连接 $s \cdot t$ 在 $A^*$ 中基于定义 7.1.1 递归地定义如下:

-   基本情况: $\lambda \cdot t ::= t$.

-   构造情况: $\langle a, s \rangle \cdot t ::= \langle a, s \cdot t \rangle$.
:::

### 7.1.1 结构归纳法

结构归纳法是一种证明递归定义的数据类型的所有元素都具有某种属性的方法. 结构归纳法证明有两个部分对应于递归定义:

-   证明每个基本情况元素具有该属性.
-   证明当构造情况用于具有该属性的元素时, 每个构造情况元素也具有该属性.

例如, 在定义 7.1.3 的连接的基本情况下, 我们定义空字符串是“左单位”, 即 $\lambda \cdot s ::= s$. 我们还希望空字符串也是“右单位”, 即 $s \cdot \lambda = s$. 作为右单位不是定义 7.1.3 的一部分, 但我们可以通过结构归纳法轻松证明:

::: lem
#### 引理 7.1.4.

$$s \cdot \lambda = s $$

对于所有 $s \in A^*$.
:::

::: prf
证明通过基于定义 7.1.3 的连接的递归定义的结构归纳法进行. 归纳假设将是

$$
P(s) ::= [s \cdot \lambda = s]. 
$$

-   基本情况: （$s = \lambda$）

$$
\begin{align*}
\lambda \cdot \lambda &= \lambda \\
&= \lambda \quad (\lambda \text{是定义 7.1.3 的左单位})\\
&= s. 
\end{align*}
$$

-   构造情况: （$s = \langle a, t \rangle$）

$$
\begin{align*}
s \cdot \lambda &= (\langle a, t \rangle) \cdot \lambda\\
&= \langle a, t \cdot \lambda \rangle \quad (\text{定义 7.1.3 的构造情况})\\
&= \langle a, t \rangle \quad (\text{根据归纳假设 } P(t))\\
&= s. 
\end{align*}
$$

所以 $P(s)$ 成立. 这完成了构造情况的证明, 并且我们通过结构归纳法得出, 等式 $s \cdot \lambda = s$ 对于所有 $s \in A^*$ 成立.
:::

我们还可以通过结构归纳法验证递归函数的属性. 例如, 让我们验证两个字符串的连接的长度是它们长度的和:

::: lem
#### 引理 7.1.5.

$$|s \cdot t| = |s| + |t|$$

对于所有 $s, t \in A^*$.
:::

::: prf
通过基于 $s \in A^*$ 的定义的结构归纳法. 归纳假设是

$$P(s) ::= \forall t \in A^* . |s \cdot t| = |s| + |t|$$

-   基本情况: （$s = \lambda$）

$$
\begin{align*}
|s \cdot t| &= |\lambda \cdot t| \\
&= |t| \quad (\text{定义 7.1.3 的基本情况})\\
&= 0 + |t| \\
&= |s| + |t| \quad (\text{定义} \ |\lambda|). 
\end{align*}
$$

-   构造情况: （$s = \langle a, r \rangle$）

$$ 
\begin{align*}
|s \cdot t| &= |\langle a, r \rangle \cdot t| \\
&= |\langle a, r \cdot t \rangle| \quad (\text{定义 7.1.3 的构造情况})\\
&= 1 + |r \cdot t| \quad (\text{定义长度的构造情况})\\
&= 1 + (|r| + |t|) \quad (\text{归纳假设 } P(r))\\
&= (1 + |r|) + |t| \\
&=|\langle a, r \rangle| + |t| \quad (\text{定义长度的构造情况})\\
&= |s| + |t|. 
\end{align*} 
$$

这证明了 $P(s)$ 成立, 完成了构造情况的证明. 通过结构归纳法, 我们得出, 对于所有字符串 $s \in A^*$, 等式 $P(s)$ 成立.
:::

这些证明说明了一般原则:

::: thm
#### 结构归纳原理

设 $P$ 是递归定义的数据类型 $R$ 上的一个谓词. 如果

-   对于每个基本情况元素 $b \in R$, $P(b)$ 成立, 并且
-   对于所有二参数构造器 $c$,

$$
[P(r) \text{ 和 } P(s)] \Rightarrow P(c(r, s))
$$

对所有 $r, s \in R$ 成立, 并且对于所有具有其他参数数量的构造器同样成立,

那么 $P(r)$ 对所有 $r \in R$ 成立.
:::

## 7.2 配对括号的字符串

令 $\{ {{\color{blue}]}}, {{\color{red}[}} \}^*$ 为所有方括号字符串的集合. 例如, 以下两个字符串在 $\{ {{\color{blue}]}}, {{\color{red}[}} \}^*$ 中:

$$
{{\color{red}[}}{{\color{blue}]}}{{\color{blue}]}}{{\color{red}[}}{{\color{red}[}}{{\color{red}[}}{{\color{red}[}}{{\color{red}[}}{{\color{blue}]}}{{\color{blue}]}} \quad \text{和} \quad {{\color{red}[}}{{\color{red}[}}{{\color{red}[}}{{\color{blue}]}}{{\color{blue}]}}{{\color{red}[}}{{\color{blue}]}}{{\color{blue}]}}{{\color{red}[}}{{\color{blue}]}}
$$

字符串 $s \in \{ {{\color{blue}]}}, {{\color{red}[}} \}^*$ 被称为匹配字符串, 如果其括号以通常的方式“匹配”. 例如, 上面的左侧字符串不是匹配的, 因为其第二个右括号没有对应的左括号. 右侧的字符串是匹配的.

我们将研究几种不同的方法来定义和证明递归定义的集合和函数上的匹配字符串的性质. 这些性质非常简单明了, 你可能会想知道它们在计算机科学中是否具有特殊意义. 答案是“现在意义不大了”. 原因之一是计算机科学的一个重大成功, 如下方文本框所述.

### 表达式解析

在20世纪50年代和60年代计算机科学的早期发展过程中, 有效的编程语言编译器的创建是一个重要问题. 编译过程中一个关键方面是表达式解析. 一个重要的问题是如何将表达式如:

$$ x + y \ast z^2 \div y + 7 $$

插入括号以确定其计算顺序——应该是:

$$ [[x + y] \ast z^2 \div y] + 7 $$

还是:

$$ x + [y \ast z^2 \div [y + 7]] $$

还是:

$$ [x + [y \ast z^2]] \div [y + 7] $$

最终, 图灵奖（计算机科学的“诺贝尔奖”）授予了罗伯特·W·弗洛伊德, 部分原因是他发现了一些简单的插入括号的程序.

在70年代和80年代, 这种解析技术被打包成从表达式语法自动生成解析器的高级编译器. 这种解析自动化非常有效, 以至于该主题不再引起关注. 到90年代, 它在计算机科学课程中基本消失了.

匹配字符串可以很好地表述为递归数据类型:

::: thm
#### 定义 7.2.1.

递归定义字符串集合 RecMatch 如下:

-   基本情况: $\lambda \in \text{RecMatch}$.

-   构造情况: 如果 $s, t \in \text{RecMatch}$, 则 ${{\color{red}[}} s {{\color{blue}]}} t \in \text{RecMatch}$.
:::

这里 ${{\color{red}[}} s {{\color{blue}]}} t$ 指字符串的连接, 完整写作 ${{\color{red}[}}\cdot(s \cdot({{\color{blue}]}} \cdot t))$.

从现在起, 我们通常会省略“$\cdot$”.

使用此定义, $\lambda \in \text{RecMatch}$ 因为基本情况, 所以令 $s = t = \lambda$ 在构造情况下意味着:

$$
{{\color{red}[}} \lambda {{\color{blue}]}} \lambda = {{\color{red}[}} {{\color{blue}]}} \in \text{RecMatch}
$$

实际上,

$$
\begin{array}{rr}
{{{\color{red}[}}\lambda{{\color{blue}]}}{{\color{red}[}}{{\color{blue}]}}={{\color{red}[}}{{\color{blue}]}}\in \text { RecMatch }} & \text { (令 } s=\lambda, t={{\color{red}[}}{{\color{blue}]}} \text { ) } \\
{{{\color{red}[}}{{\color{red}[}}{{\color{blue}]}}{{\color{blue}]}} \lambda={{\color{red}[}}{{\color{red}[}}{{\color{blue}]}}{{\color{blue}]}} \in \text { RecMatch }} & \text { (令 } s={{\color{red}[}}{{\color{blue}]}}, t=\lambda \text { ) } \\
{{{\color{red}[}}{{\color{red}[}}{{\color{blue}]}}{{\color{blue}]}}{{\color{red}[}}{{\color{blue}]}} \in \text { RecMatch }} & \text { (令 } s={{\color{red}[}}{{\color{blue}]}}, t={{\color{red}[}}{{\color{blue}]}} \text { ) }
\end{array}
$$

很明显, 要使括号匹配, 左右括号的数量必须相等. 为了进一步练习, 让我们仔细证明这一点, 从递归定义开始, 首先定义字符串 $s$ 中字符 $c \in A$ 出现的次数 $\#_c(s)$ 的递归定义:

::: thm
#### 定义 7.2.2.

-   基本情况: $\#_c(\lambda) ::= 0$.

-   构造情况:

    $$
    \#_c(\langle a, s \rangle) ::= \begin{cases} 
    \#_c(s) & \text{如果 } a \ne c, \\
    1 + \#_c(s) & \text{如果 } a = c. 
    \end{cases}
    $$
:::

以下引理直接通过定义 7.2.2 的结构归纳法得到. 我们将证明留作练习（问题 7.9）:

::: lem
#### 引理 7.2.3.

$$
\#_c(s \cdot t) = \#_c(s) + \#_c(t)
$$

对所有 $s, t \in A^*$.
:::

::: lem
每个字符串在 RecMatch 中具有相等数量的左括号和右括号.
:::

::: prf
**证明:** 证明通过结构归纳法进行, 归纳假设为$P(s) ::= [ \#_{{{\color{red}[}}} (s) = \#_{{{\color{blue}]}}} (s) ]$.

-   基本情况: $P(\lambda)$ 成立, 因为

    $$
    \#_{{{\color{red}[}}} (\lambda) = 0 = \#_{{{\color{blue}]}}} (\lambda)
    $$

    根据定义 7.2.2 的基本情况.

-   构造情况: 根据结构归纳假设, 我们假设 $P(s)$ 和 $P(t)$ 并且必须证明 $P([ s ] t)$:

$$
\begin{align*}
\#_{{{\color{red}[}}} ({{\color{red}[}} s {{\color{blue}]}} t) &= \#_{{{\color{red}[}}} ({{\color{red}[}}) + \#_{{{\color{red}[}}} (s) + \#_{{{\color{red}[}}} ({{\color{blue}]}}) + \#_{{{\color{red}[}}} (t) \\
&= 1 + \#_{{{\color{red}[}}} (s) + 0 + \#_{{{\color{red}[}}} (t) \\
&= 1 + \#_{{{\color{red}[}}} (s) + 0 + \#_{{{\color{red}[}}} (t) \quad (\text{根据 } P(s) \text{ 和 } P(t))\\
&= 0 + \#_{{{\color{red}[}}} (s) + 1 + \#_{{{\color{red}[}}} (t) \\
&= \#_{{{\color{blue}]}}} ({{\color{red}[}}) + \#_{{{\color{red}[}}} (s) + \#_{{{\color{red}[}}} ({{\color{blue}]}}) + \#_{{{\color{blue}]}}} (t) \\
&= \#_{{{\color{blue}]}}} ({{\color{red}[}} s {{\color{blue}]}} t)
\end{align*}
$$

这完成了构造情况的证明. 我们通过结构归纳法得出 $P(s)$ 对所有 $s \in \text{RecMatch}$ 成立. ■
:::

::: warning
当数据类型的递归定义允许同一元素以多种方式构造时, 该定义被称为 *模棱两可* 的. 我们小心地选择了一个明确的 RecMatch 定义, 以确保基于其定义递归定义的函数总是定义良好的. 通常情况下, 在模棱两可的数据类型定义上递归定义函数将无法正常工作. 为了说明问题, 这里是匹配字符串的另一个定义.
:::

::: thm
#### 定义 7.2.4.

定义集合 AmbRecMatch $\subseteq \{{{\color{blue}]}},{{\color{red}[}} \}^*$ 递归如下:

-   基本情况: $\lambda \in \text{AmbRecMatch}$,

-   构造情况: 如果 $s, t \in \text{AmbRecMatch}$, 则字符串 ${{\color{red}[}} s {{\color{blue}]}}$ 和 $st$ 也在 $\text{AmbRecMatch}$ 中.
:::

很容易看出, AmbRecMatch 的定义只是另一种定义 RecMatch 的方式, 即 AmbRecMatch = RecMatch（见问题 7.19）. AmbRecMatch 的定义可以说更容易理解, 但我们没有使用它, 因为它是模棱两可的, 而 RecMatch 的更复杂的定义是明确的. 这就是为什么这很重要. 让我们根据 $s \in \text{AmbRecMatch}$ 的定义递归地定义构造匹配字符串 $s$ 的操作数 $f(s)$:

$$
f(\lambda) ::= 0,
$$

$$
f({{\color{red}[}} s {{\color{blue}]}}) ::= 1 + f(s),
$$

$$
f(st) ::= 1 + f(s) + f(t). 
$$

这个定义看起来没问题, 但事实并非如此: $f(\lambda)$ 最终有两个值, 因此:

$$
\begin{align*}
0 &= f(\lambda) \quad (\text{基本情况}) \\
  &= f(\lambda \cdot \lambda) \quad (\text{连接定义, 基本情况}) \\
  &= 1 + f(\lambda) + f(\lambda) \quad (\text{连接情况}) \\
  &= 1 + 0 + 0 = 1 \quad (\text{基本情况}). 
\end{align*}
$$

这绝对不是我们想要的情况！

## 7.3 非负整数上的递归函数

非负整数可以理解为一种递归数据类型.

::: thm
#### 定义 7.3.1.

集合 $\mathbb{N}$ 是一种递归定义的数据类型, 定义如下:

-   $0 \in \mathbb{N}$.

-   如果 $n \in \mathbb{N}$, 那么 $n + 1$ 的后继 $n + 1 \in \mathbb{N}$.
:::

这里的要点是要明确, 普通的归纳法只是基于递归定义 7.3.1 的结构归纳法的特例. 这也解释了为什么非负整数上的熟悉的递归函数定义是合理的.

### 7.3.1 一些标准的 $\mathbb{N}$ 上的递归函数

::: eg
#### 例 7.3.2.

阶乘函数. 这个函数通常写作“$n!$”. 在后面的章节中你会看到很多它的应用. 这里, 我们使用符号 $\text{fac}(n)$:

-   $\text{fac}(0) ::= 1$.

-   $\text{fac}(n + 1) ::= (n + 1) \cdot \text{fac}(n)$, 当 $n \geq 0$ 时.
:::

::: eg
#### 例 7.3.3.

求和符号. 令 “$S(n)$” 代表表达式 $\sum_{i=1}^{n} f(i)$. 我们可以用以下规则递归地定义 $S(n)$:

-   $S(0) ::= 0$.

-   $S(n + 1) ::= f(n + 1) + S(n)$, 当 $n \geq 0$ 时.
:::

### 7.3.2 定义不良的函数

在递归定义函数时, 还需要注意一些错误. 主要问题出现在递归定义不遵循底层数据类型的递归定义时. 下面是一些看起来像非负整数上函数的好定义, 但实际上并不是.

$$
f_1(n) ::= 2 + f_1(n - 1). 
$$

这个“定义”没有基本情况. 如果某个函数 $f_1$ 满足 (7.2), 那么在 $f_1$ 的值上加一个常数得到的函数也满足 (7.2). 因此, 方程 (7.2) 并不能唯一地定义 $f_1$.

$$
f_2(n) ::= \begin{cases} 
0, & \text{如果 } n = 0, \\
f_2(n + 1), & \text{否则}. 
\end{cases}
$$

这个“定义”有一个基本情况, 但仍然不能唯一确定 $f_2$. 任何在 $0$ 处为 $0$ 且在其他地方为常数的函数都满足这个规范, 因此 (7.3) 也没有唯一地定义任何东西.

在典型的编程语言中, $f_2(1)$ 的求值将从递归调用 $f_2(2)$ 开始, 这将导致递归调用 $f_2(3)$, ..., 递归调用不断继续, 没有结束. 这种“操作”方法将 (7.3) 解释为定义一个在 $0$ 处定义的部分函数 $f_2$.

$$
f_3(n) ::= \begin{cases} 
0, & \text{如果 } n 可以被2整除, \\
1, & \text{如果 } n 可以被3整除, \\
2, & \text{否则}. 
\end{cases}
$$

这个“定义”是不一致的: 它要求 $f_3(6) = 0$ 和 $f_3(6) = 1$, 所以 (7.4) 并没有定义任何东西.

数学家们对这个函数规范已经思考了一段时间, 这就是所谓的考拉兹猜想:

$$
f_4(n) ::= \begin{cases} 
1, & \text{如果 } n \leq 1, \\
f_4(n/2), & \text{如果 } n > 1 \text{ 且 } n \text{ 为偶数}, \\
f_4(3n + 1), & \text{如果 } n \text{ 为奇数}. 
\end{cases}
$$

例如, $f_4(3) = 1$, 因为

$$
f_4(3) ::= f_4(10) ::= f_4(5) ::= f_4(16) ::= f_4(8) ::= f_4(4) ::= f_4(2) ::= f_4(1) ::= 1. 
$$

常数函数等于1将满足 (7.5), 但还不清楚是否有其他函数也满足. (7.5) 的第三种情况以 $n$ 的函数形式指定了 $f_4$, 因此无法通过 $\mathbb{N}$ 上的归纳法证明它. 已知满足 (7.5) 的任何 $f_4$ 对于所有 $n$ 直到超过 $10^{18}$ 都等于1.

最后一个例子是 Ackermann 函数, 这是一个增长极快的两个非负参数的函数. 它的逆函数相应地增长缓慢——比 $\log n$, $\log \log n$, $\log \log \log n$ 等等都要慢, 但确实会增长. 这种逆函数实际上出现在分析一种有用的、高效的过程时, 称为联合-查找算法. 该算法被推测为在其输入大小的线性步数内运行, 但结果是“线性”的慢增长系数几乎等于逆 Ackermann 函数. 这意味着实际上, 联合-查找是线性的, 因为对任何可能出现的输入, 其理论增长系数小于5.

Ackermann 函数可以递归定义为函数 $A$, 给出以下规则:

$$
A(m, n) = 2n \quad \text{如果 } m = 0 \text{ 或 } n \leq 1,
$$

$$
A(m, n) = A(m - 1, A(m, n - 1)) \quad \text{否则}. 
$$

这些规则是不同寻常的, 因为 $A(m, n)$ 的定义涉及对可能比 $m$ 和 $n$ 大得多的参数的评估. 上面 $f_2$ 的定义显示了如何在较小的参数值上定义函数值会很容易导致不终止的求值. Ackermann 函数的定义实际上是可以的, 但证明这一点需要一些巧妙的方法（见问题 7.25）.

## 7.4 算术表达式

表达式求值是编程语言的一个关键特性, 识别表达式作为递归数据类型是理解如何处理它们的关键.

为了说明这种方法, 我们将使用一个玩具示例: 只涉及一个变量 “$x$” 的算术表达式, 例如 $3x^2 + 2x + 1$. 我们将这种表达式的数据类型称为 Aexp. 它的定义如下:

### 定义 7.4.1

-   **基本情况**:
    -   变量 $x$ 在 Aexp 中.
    -   任何非负整数 $k$ 的阿拉伯数字 $k$ 在 Aexp 中.
-   **构造情况**: 如果 $e, f \in$ Aexp, 那么
    -   ${{\color{red}[}} e + f {{\color{blue}]}} \in$ Aexp. 表达式 ${{\color{red}[}} e + f {{\color{blue}]}}$ 被称为和. Aexp 的 $e$ 和 $f$ 被称为和的组成部分；它们也被称为加数.
    -   ${{\color{red}[}} e * f {{\color{blue}]}} \in$ Aexp. 表达式 ${{\color{red}[}} e * f {{\color{blue}]}}$ 被称为积. Aexp 的 $e$ 和 $f$ 被称为积的组成部分；它们也被称为乘数和被乘数.
    -   ${{\color{red}[}} - e {{\color{blue}]}} \in$ Aexp. 表达式 ${{\color{red}[}} - e {{\color{blue}]}}$ 被称为负数.

注意, Aexp 是完全括起来的, 并且不允许指数. 因此, 多项式表达式 $3x^2 + 2x + 1$ 的 Aexp 版本将正式写作:

$$
{{\color{red}[}} {{\color{red}[}} 3 * {{\color{red}[}} x * x {{\color{blue}]}} {{\color{blue}]}} + {{\color{red}[}} {{\color{red}[}} 2 * x {{\color{blue}]}} + 1 {{\color{blue}]}} {{\color{blue}]}} \tag{7.8}
$$

这些括号和 \* 符号使得例子变得复杂, 所以我们通常会使用更简单的表达式, 例如“$3x^2 + 2x + 1$”而不是(7.8). 但重要的是要认识到 $3x^2 + 2x + 1$ 不是 Aexp, 它是 Aexp 的缩写.

### 7.4.1 使用 Aexp 的求值和替换

#### 求值 Aexp

由于 Aexp 中唯一的变量是 $x$, 因此 Aexp 的值由 $x$ 的值决定. 例如, 如果 $x$ 的值为 3, 那么 $3x^2 + 2x + 1$ 的值为 34. 通常, 给定任何 Aexp $e$ 和变量 $x$ 的整数值 $n$, 我们可以求值 $e$ 以找到它的值 $\text{eval}(e, n)$. 指定这个求值过程是简单且有用的, 可以使用递归定义.

::: thm **定义 7.4.2.** 求值函数 $\text{eval} : \text{Aexp} \times \mathbb{Z} \to \mathbb{Z}$ 递归地定义在表达式 $e \in$ Aexp 上, 如下. 令 $n$ 为任意整数.

-   **基本情况**: $$
    \text{eval}(x, n) ::= n \quad \text{（变量 } x \text{ 的值为 } n) \tag{7.9}
    $$ $$
    \text{eval}(k, n) ::= k \quad \text{（数值 } k \text{ 的值为 } k \text{, 无论 } x \text{ 是什么)} \tag{7.10}
    $$

-   **构造情况**: $$
    \text{eval}({{\color{red}[}} e_1 + e_2 {{\color{blue}]}}, n) ::= \text{eval}(e_1, n) + \text{eval}(e_2, n) \tag{7.11}
    $$ $$
    \text{eval}({{\color{red}[}} e_1 * e_2 {{\color{blue}]}}, n) ::= \text{eval}(e_1, n) \cdot \text{eval}(e_2, n) \tag{7.12}
    $$ $$
    \text{eval}({{\color{red}[}} - e_1 {{\color{blue}]}}, n) ::= - \text{eval}(e_1, n) \tag{7.13}
    $$

例如, 下面是求值函数的递归定义如何求得 $3 + x^2$ 在 $x = 2$ 时的值:

$$
\begin{align*}
\text{eval}({{\color{red}[}} 3 + {{\color{red}[}} x * x {{\color{blue}]}} {{\color{blue}]}}, 2) &= \text{eval}(3, 2) + \text{eval}({{\color{red}[}} x * x {{\color{blue}]}}, 2) \quad (\text{通过定义 7.4.2.7.11}) \\
&= 3 + \text{eval}({{\color{red}[}} x * x {{\color{blue}]}}, 2) \quad (\text{通过定义 7.4.2.7.10}) \\
&= 3 + (\text{eval}(x, 2) \cdot \text{eval}(x, 2)) \quad (\text{通过定义 7.4.2.7.12}) \\
&= 3 + (2 \cdot 2) \quad (\text{通过定义 7.4.2.7.9}) \\
&= 3 + 4 = 7. 
\end{align*}
$$

#### 在 Aexp 中替换

变量的表达式替换是编译器和代数系统常用的标准操作. 例如, 在表达式 $x(x - 1)$ 中将 $3x$ 替换为 $x$ 的结果将是 $3x(3x - 1)$. 我们将使用一般符号 $\text{subst}(f, e)$ 来表示在 Aexp $e$ 中用 Aexp $f$ 替换每个 $x$. 所以我们刚才解释为

$$
\text{subst}(3x, x(x - 1)) = 3x(3x - 1). 
$$

这个替换函数有一个简单的递归定义.

::: thm

#### 定义 7.4.3.

替换函数 $\text{subst}$ 从 Aexp $\times$ Aexp 到 Aexp 递归地定义在表达式 $e \in$ Aexp 上, 如下. 令 $f$ 为任意 Aexp.

-   **基本情况**:

    $$
    \text{subst}(f, x) ::= f \quad \text{（将 } f \text{ 替换为变量 } x \text{ 就是给出 } f) \tag{7.14}
    $$

    $$
    \text{subst}(f, k) ::= k \quad \text{（替换到数字中什么也不做）} \tag{7.15}
    $$

-   **构造情况**:

    $$
    \text{subst}(f, {{\color{red}[}} e_1 + e_2 {{\color{blue}]}}) ::= {{\color{red}[}} \text{subst}(f, e_1) + \text{subst}(f, e_2) {{\color{blue}]}} \tag{7.16}
    $$

    $$
    \text{subst}(f, {{\color{red}[}} e_1 * e_2 {{\color{blue}]}}) ::= {{\color{red}[}} \text{subst}(f, e_1) * \text{subst}(f, e_2) {{\color{blue}]}} \tag{7.17}
    $$

    $$
    \text{subst}(f, {{\color{red}[}} - e_1 {{\color{blue}]}}) ::= {{\color{red}[}} - \text{subst}(f, e_1) {{\color{blue}]}} \tag{7.18}
    $$

这里是替换函数的递归定义如何找到在表达式 $x(x - 1)$ 中将 $3x$ 替换为 $x$ 的结果:

$$
\begin{align*}
\text{subst}(3x, x(x - 1)) &= \text{subst}(3x, {{\color{red}[}} x * {{\color{red}[}} x - 1 {{\color{blue}]}} {{\color{blue}]}}) \quad (\text{取消缩写}) \\
&= {{\color{red}[}} \text{subst}(3x, x) * {{\color{red}[}} x - 1 {{\color{blue}]}} {{\color{blue}]}} \quad (\text{通过定义 7.4.3 和 7.17}) \\
&= {{\color{red}[}} 3x * {{\color{red}[}} x - 1 {{\color{blue}]}} {{\color{blue}]}} \quad (\text{通过定义 7.4.3 和 7.14}) \\
&= {{\color{red}[}} 3x * {{\color{red}[}} \text{subst}(3x, x) - \text{subst}(3x, 1) {{\color{blue}]}} {{\color{blue}]}} \quad (\text{通过定义 7.4.3 和 7.16}) \\
&= {{\color{red}[}} 3x * {{\color{red}[}} 3x - 1 {{\color{blue}]}} {{\color{blue}]}} \quad (\text{通过定义 7.4.3 和 7.14 & 7.15}) \\
&= {{\color{red}[}} 3x * {{\color{red}[}} 3x - 1 {{\color{blue}]}} {{\color{blue}]}} \quad (\text{缩写})
\end{align*} 
$$

现在假设我们必须在 $x = 2$ 时找到 $\text{subst}(3x, x(x - 1))$ 的值. 有两种方法. 首先, 我们实际上可以做上面的替换得到 $3x(3x - 1)$, 然后我们可以求 $3x(3x - 1)$ 在 $x = 2$ 时的值, 即我们可以递归地计算 $\text{eval}(3x(3x - 1), 2)$ 以获得最终值 30. 这种方法用以下表达式描述:

$$
\text{eval}(\text{subst}(3x, x(x - 1)), 2) \tag{7.19}
$$

在编程术语中, 这称为使用替换模型进行求值. 用这种方法, 公式 $3x$ 在替换后出现两次, 因此计算其值的乘法 $3 \cdot 2$ 被执行了两次.

第二种方法称为使用环境模型进行求值. 在这里, 为了计算 (7.19) 的值, 我们在 $x = 2$ 时求 $3x$ 只需一次乘法得到值 6. 然后当 $x$ 有这个值 6 时, 我们求 $x(x - 1)$ 得到值 $6 \cdot 5 = 30$. 这种方法用以下表达式描述:

$$
\text{eval}(x(x - 1), \text{eval}(3x, 2)) \tag{7.20}
$$

环境模型仅计算一次 $3x$ 的值, 因此计算 (7.20) 所需的乘法比替换模型少.

这是一个很好的地方停下来并亲自完成这个例子（问题 7.26）.

(7.19) 和 (7.20) 的最终整数值相同并不奇怪. 替换模型和环境模型将始终生成相同的最终值. 我们可以通过直接遵循两种方法的定义的结构归纳法证明这一点. 更确切地说, 我们要证明的是:

::: thm
### 定理 7.4.4.

对于所有表达式 $e, f \in \text{Aexp}$ 和 $n \in \mathbb{Z}$,

$$
\text{eval}(\text{subst}(f, e), n) = \text{eval}(e, \text{eval}(f, n)).  \tag{7.21}
$$
:::

::: prf
证明通过对 $e$ 的结构归纳法进行.

-   **基本情况**:
    -   情况 [$x$]: 方程 (7.21) 的左侧通过定义 7.4.3 的替换函数中的基本情况等于 $\text{eval}(f, n)$；右侧也通过定义 7.4.2 的求值函数中的基本情况等于 $\text{eval}(f, n)$.
    -   情况 [$k$]: 方程 (7.21) 的左侧通过定义 7.4.3 和 7.4.2 的替换和求值函数的基本情况等于 $k$. 同样, 右侧也通过定义 7.4.2 的基本情况等于 $k$.
-   **构造情况**:
    -   情况 ${{\color{red}[}} e_1 + e_2 {{\color{blue}]}}$: 根据结构归纳假设 (7.21), 我们可以假设对于所有 $f \in \text{Aexp}$ 和 $n \in \mathbb{Z}$,

        $$
        \text{eval}(\text{subst}(f, e_i), n) = \text{eval}(e_i, \text{eval}(f, n)) \tag{7.22}
        $$ 对于 $i = 1, 2$. 我们要证明

        $$
        \text{eval}(\text{subst}(f, {{\color{red}[}} e_1 + e_2 {{\color{blue}]}}), n) = \text{eval}({{\color{red}[}} e_1 + e_2 {{\color{blue}]}}, \text{eval}(f, n)).  \tag{7.23}
        $$

        (7.23) 的左侧等于

        $$
        \text{eval}({{\color{red}[}} \text{subst}(f, e_1) + \text{subst}(f, e_2) {{\color{blue}]}}, n)
        $$ 根据定义 7.4.3.7.16 对和表达式的替换. 但这等于

        $$
        \text{eval}(\text{subst}(f, e_1), n) + \text{eval}(\text{subst}(f, e_2), n)
        $$ 根据定义 7.4.2.(7.11) 对和表达式的求值. 根据归纳假设 (7.22), 这又等于

        $$
        \text{eval}(e_1, \text{eval}(f, n)) + \text{eval}(e_2, \text{eval}(f, n)). 
        $$

        最后, 这个表达式等于 (7.23) 的右侧, 根据定义 7.4.2.(7.11) 对和表达式的求值. 这证明了这种情况下的 (7.23).

    -   情况 ${{\color{red}[}} e_1 * e_2 {{\color{blue}]}}$ 类似.

    -   情况 ${{\color{red}[}} - e_1 {{\color{blue}]}}$ 更简单.

这涵盖了所有构造情况, 因此通过结构归纳法完成了证明.
:::

## 7.5 游戏作为递归数据类型

国际象棋、跳棋、围棋和尼姆游戏是 *完美信息的双人游戏* 的例子. 这些是两名玩家（玩家1和玩家2）交替移动的游戏, "完美信息" 意味着游戏中任何时刻的情况对双方玩家是完全可见的. 例如, 在国际象棋中, 棋盘上的棋子位置完全决定了游戏的其余部分可以由每个玩家如何进行. 而大多数纸牌游戏不是完美信息的游戏, 因为双方玩家都看不到对方的手牌.

在本节中, 我们将研究完美信息的双人输赢游戏, WL-2PerGm. 我们将定义 WL-2PerGm 作为递归数据类型, 然后通过结构归纳法证明这些游戏的获胜策略的基本定理. 递归定义的思想是认识到游戏过程中任何时候的情况本身可以视为新游戏的开始. 对于尼姆游戏, 这一点最清晰.

尼姆游戏从几堆石头开始. 游戏中的一步包括从一个堆中移除一些正数的石头. 玩家1和玩家2轮流移动, 谁拿到最后一块石头谁就赢. 所以如果只有一堆石头, 第一个移动的玩家通过拿走整堆石头获胜. 在其他情况下, 如果还有两堆石头, 每堆石头数量相同, 则第二个移动的玩家可以通过模仿第一个玩家的策略来保证获胜. 例如, 这意味着如果第一个玩家从一个堆中移除三块石头, 第二个玩家则从另一个堆中移除三块石头. 在这一点上, 值得稍作思考, 为什么模仿策略保证了第二个玩家的胜利.

我们可以将尼姆游戏中的第一次移动视为简单地选择一个不同的有待游戏的石头堆游戏. 例如, 对于初始堆为 3、4 和 5 块石头的尼姆游戏, 第一次玩家可以从第一个堆中移除一到三块石头, 导致三种可能的石头堆:

$$
\langle 2, 4, 5 \rangle, \langle 1, 4, 5 \rangle, \langle 4, 5 \rangle. 
$$

类似地, 第一次玩家有五种可能的方法从最后一个堆中移除石头, 导致五种可能的石头堆:

$$
\langle 3, 4, 4 \rangle, \langle 3, 4, 3 \rangle, \langle 3, 4, 2 \rangle, \langle 3, 4, 1 \rangle, \langle 3, 4 \rangle. 
$$

因此, 尼姆 (3, 4, 5) 的所有性质都由第一次移动可能产生的 3 + 4 + 5 = 12 个尼姆游戏的集合捕捉.

有了这个想法, 我们现在给出正式定义.

::: def
#### 定义 7.5.1.

完美信息的双人输赢游戏类 WL-2PerGm(Win Lose 2 Person Game) 递归地定义如下:

-   基本情况: win 和 lose 是 WL-2PerGm.
-   构造情况: 如果 $G$ 是 WL-2PerGm 的非空集合, 那么 $G$ 是 WL-2PerGm 游戏. 每个游戏 $M \in G$ 被称为 $G$ 的可能第一次移动.
:::

一个 WL-2PerGm 游戏的一个玩法是一个移动序列, 以玩家1的胜利或失败告终, 或永远继续而没有结果. 更正式地:

::: def
#### 定义

一个 WL-2PerGm 游戏 $G$ 的玩法及其结果根据 WL-2PerGm 的定义递归地定义如下:

-   基本情况: （$G = \text{win}$）长度为一的序列 $\langle \text{win} \rangle$ 是 $G$ 的玩法. 其结果是胜利.
-   基本情况: （$G = \text{lose}$）长度为一的序列 $\langle \text{lose} \rangle$ 是 $G$ 的玩法. 其结果是失败.
-   构造情况: （$G$ 是 WL-2PerGm 的非空集合）. $G$ 的玩法是一个序列, 从 $G$ 开始, 后跟某个游戏 $M \in G$ 的玩法 $P_M$. 如果有结果, 则玩法的结果是 $P_M$ 的结果.
:::

某些游戏的基本规则确实允许永远进行下去的玩法. 例如, 一个玩家可能只是不断移动同一个棋子, 如果他的对手也这么做, 玩法可能永远持续下去. 但 WL-2PerGm 游戏的递归定义实际上排除了无限玩法的可能性.

::: lem
#### 引理 7.5.2.

WL-2PerGm 游戏 $G$ 的每个玩法都有结果.
:::

::: prf
我们通过结构归纳法证明引理 7.5.2, 使用引理作为归纳假设.

-   基本情况: （$G = \text{win}$）. 只有一个 $G$ 的玩法, 即长度为一的玩法 $\langle \text{win} \rangle$, 其结果是胜利.
-   基本情况: （$G = \text{lose}$）. 同样, 结果为失败.
-   构造情况: （$G$ 是 WL-2PerGm 的非空集合）. $G$ 的玩法根据定义包含 $G$ 后跟某个 $M \in G$ 的玩法 $P_M$. 根据结构归纳法, $P_M$ 必须是某个长度为 $n$ 的有限序列, 以某个结果结束. 因此, $G$ 的玩法是长度为 $n + 1$ 的序列, 以相同的结果结束. ■
:::

在跳棋、国际象棋、围棋和尼姆游戏中, 只有尼姆是真正的输赢游戏, 其他游戏可能以平局（和棋、僵局、持平）结束. 然而, 通过将这些游戏中的平局视为玩家1的失败, 关于输赢游戏的结果也适用于有平局的游戏.

### 7.5.1 游戏策略

玩家的策略是一个规则, 告诉玩家在轮到他们时该做哪个移动. 更准确地说, 策略 $s$ 是从游戏到游戏的函数, 具有 $s(G) \in G$ 的属性, 适用于所有游戏 $G$. 两名玩家的一对策略准确地决定了玩家选择的移动, 因此决定了游戏的唯一玩法, 取决于谁先移动.

关于游戏的一个关键问题是, 哪种策略能确保玩家获胜. 玩家1 想要一个结果保证为胜利的策略, 玩家2 想要一个结果保证为玩家1 失败的策略.

### 7.5.2 输赢游戏的基本定理

WL-2PerGm 游戏的基本定理指出, 一名玩家总有一个固定的“获胜”策略, 保证对抗任何可能的对手策略都能获胜.

考虑国际象棋, 这似乎令人惊讶. 认真对待国际象棋的玩家通常对他们的意图进行保密, 相信对手可以利用知道他们的策略. 他们担心的是对手可以针对他们选择的任何策略量身定制一个策略来击败它.

但基本定理说的是不同的. 在理论上, 在任何输赢平局游戏中, 如国际象棋或跳棋, 每个玩家都有一个策略, 即使对手知道他们的策略也能保证获胜或平局.

即:

-   一名玩家有获胜策略, 或
-   两名玩家都有策略, 保证他们至多得到平局.

虽然基本定理揭示了关于游戏的深刻事实, 但它有一个非常简单的结构归纳法证明.

::: thm
#### 定理 7.5.3. [输赢游戏的基本定理]

对于任何 WL-2PerGm 游戏 $G$, 一名玩家有获胜策略.
:::

::: prf
证明通过对 $G \in \text{WL-2PerGm}$ 的定义的结构归纳法进行. 归纳假设是其中一名玩家有获胜策略.

-   基本情况: （$G = \text{win}$ 或 $\text{lose}$）. 那么对于每个玩家只有一种可能的策略, 即不做任何事并以结果 $G$ 结束.

-   构造情况: （$G$ 是 WL-2PerGm 的非空集合）. 通过结构归纳法我们可以假设对于每个 $M \in G$, 一名玩家有获胜策略. 注意, 由于玩家交替移动, $G$ 中的第一个玩家在 $M$ 中成为第二个玩家.

    现在, 如果有一个移动 $M_0 \in G$, 其中第二个玩家在 (

M_0) 中有获胜策略, 那么 $G$ 中的第一个玩家有一个简单的获胜策略: 选择 $M_0$ 作为第一次移动, 然后跟随第二个玩家在 $M_0$ 中的获胜策略.

另一方面, 如果 $G$ 中没有 $M \in G$ 对第二个玩家有获胜策略, 那么我们可以通过归纳得出每个 $M \in G$ 对 $M$ 中的第一个玩家有获胜策略. 现在 $G$ 中的第二个玩家有一个简单的获胜策略, 即如果 $G$ 中的第一个玩家移动 $M$, 那么 $G$ 中的第二个玩家应该遵循 $M$ 中的第一个玩家的获胜策略.
:::

### 无限游戏

那么我们何时会遇到有无限次首次移动的游戏呢？假设我们玩一个有 $n$ 场国际象棋比赛的锦标赛, 对于某个正整数 $n$. 如果我们同意一个规则, 将 $n$ 场国际象棋比赛的回报组合成整个锦标赛的最终回报, 那么这个锦标赛将是一个 WL-2PerGm.

在 $n$ 场国际象棋比赛的任何阶段, 只有有限数量的可能移动, 但我们可以定义一个元国际象棋锦标赛, 其首次移动是选择任何正整数 $n$, 然后我们玩一个 $n$ 场比赛的锦标赛. 现在, 元国际象棋锦标赛有无限次首次移动.

当然, 只有元国际象棋锦标赛的第一次移动是无限的, 但随后我们可以设置一个由 $n$ 个元国际象棋锦标赛组成的锦标赛. 这将是一个具有 $n$ 次可能无限移动的游戏. 然后我们可以有一个元-元国际象棋锦标赛, 其第一次移动是选择有多少个元国际象棋锦标赛来玩. 这个元-元国际象棋锦标赛将有无限次无限移动. 然后我们可以继续到元-元-元国际象棋锦标赛……

虽然这些元游戏可能看起来很荒谬或奇怪, 但它们的怪异性并不能使基本定理失效: 在每个这样的游戏中, 其中一个玩家将有获胜策略.

注意, 虽然定理 7.5.3 保证了获胜策略, 但其证明没有说明哪个玩家有这个策略. 对于问题 4.7 的子集取走游戏和最熟悉的 2PerGm 游戏, 如国际象棋、围棋等, 没有人知道哪个玩家有获胜策略.

## 7.6 计算机科学中的归纳法

归纳法是一种强大且应用广泛的证明技术, 这就是为什么我们将整整两章都专门介绍它的原因. 强归纳法及其普通归纳法的特例适用于任何具有非负整数大小的事物——这包括非常多的事物, 包括所有逐步的计算过程.

结构归纳法则超越了数字计数, 提供了一种简单、自然的方法来证明关于递归数据类型和递归计算的内容.

在许多情况下, 可以为递归定义的数据定义一个非负整数大小, 例如字符串的长度或 Aexp 中的操作次数. 然后, 可以通过对其大小进行普通归纳法来证明数据的性质. 但是这种方法通常比结构归纳法产生更繁琐的证明.

事实上, 结构归纳法在理论上比普通归纳法更强大. 然而, 它仅在处理关于无限数据类型（例如无限树）的推理时才更强大, 因此这种更大的力量在实践中并不重要. 重要的是, 对于递归定义的数据类型, 结构归纳法是一种简单而自然的方法. 这使得它成为每个计算机科学家都应采用的技术.
